# 保守式 GC

保守式 GC 和准确式 GC 对应，指的是“不能识别指针和非指针的 GC”。

不明确的根

我们知道 GC 算法需要从根开始检测，找出活跃的对象，而一般根可以分为以下几个部分：

-   寄存器；
-   调用栈；
-   全局变量空间。

0xb7c7b6d0，既可以是一个指针，也可以是一个 int 类型的值，对于保守式 GC 来说就无法识别它真正的类型。因此保守式 GC 会以“某种精度”来识别指针：

-   是不是字对齐的值；
-   是不是指向堆；
-   是不是指向对象开头。

当然即使在这种程度的检测下，依然还会有一些值被错误识别成指针，假如采用标记清除算法，它在运行过程中会对这些“假指针”指向的对象打上标记，从而可能错误的保留了一些非活跃对象，这种清除方式是非常保守的（看到可疑的值就当作指针，并可能保留一些非活跃的对象），因此被称为保守式 GC。

优点：GC 处理程序不依赖语言程序的支援，处理简单。

缺点：

-   保守式 GC 会将可以的值当做指针，这会付出额外的扫描成本；
-   在一些特殊情况下，一些非指针指向了某个本来应该被回收的对象，而该对象又引用了许多其他对象，这就严重压迫了堆；
-   与会移动对象的 GC 算法（如 GC 复制算法、标记压缩算法）不兼容，因为对象移动后需要更新指针的值，但在保守式 GC 中，这个“指针”可能是个非指针，重写了非指针会造成严重的 bug。

计算机没有通过加一个中间层解决不了的问题，如果有，那就再加一层。针对保守式 GC 与一些会移动对象的 GC 算法不兼容的问题，有人提出了“间接引用”，即引入一个句柄作为根和对象的中间层，每个对象都有一个句柄，这些句柄中会保存对象的指针。当 GC 算法移动对象时，句柄中保存的指针值发生变化，而根仍指向原来的句柄，这就避免了对象移动修改非指针的问题。接入了句柄方式，保守式 GC 也能与 GC 复制算法、GC 标记压缩算法兼容，但由于访问对象多了句柄层，这又会导致语言性能受到影响（原来访问对象只需要一次，现在变成了两次）。

# 准确式 GC

准确式 GC 基于能准确识别指针和非指针的前提来执行 GC。

## 打标签

## 不把寄存器和栈当做根



# 间接引用





