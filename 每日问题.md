### 1. C&C++的宏定义的作用、应用场景，为什么有大量的宏定义？



### 2. 什么是可重入锁？Java的锁超时怎么使用？

可重入锁指获得该锁的线程在内部可以再次获得该锁而不会报错。



### 3. 反射和new关键字创建对象有什么区别？为什么使用反射？

反射创建实际上把new分解成了两步：

1. 调用class的加载方法加载某个类（`Class.forName()`)；
2. 通过 newInstance() 创建。

区别：

| newInstance      | new                        |
| ---------------- | -------------------------- |
| 弱类型（Object） | 强类型                     |
| 低效率           | 相对高效                   |
| 只能调用无参构造 | 可以调用任意public构造方法 |

如果没有反射机制，每次增加类时，**都需要把类的class文件放在类路径中，再修改源代码new这个类**产生对应类的对象；

有了反射机制后，**只需要在配置文件写上相应的类名称，再通过io流读取配置文件中的类名，即可通过class.forName()方法找出相应的class文件并加载进内存中，再通过newInstance()方法创建一个对象**，此时的对象是一个Object类型的对象，需要转换成相对应的类类型。这样就可以在不修改源代码的情况下通过修改配置文件进行功能的更新和扩展了。



### 4. HashMap 迭代器修改值的问题？



### 5. Maven **代理和私服的区别**？

私服指搭建在局域网内部的仓库，本身是一个仓库，也可以提供许多内部组织的插件和依赖。

代理是用于拦截远程仓库请求，从自己这边找出构件返回给用户。

很多私服搭建工具往往也提供mirror服务。



### 6. 原生态类型有没有泛型参数

没有，通过反射泛型获取不到。



### 7. 什么是大小端？

大端：高位字节在低位地址，地址由小向大增加，而数据从高位往低位放，和字符串显示顺序一致

小端：高位字节在高位地址

一般操作系统都是小端，而通讯协议是大端的。

Java和所有的网络通讯协议都是使用Big-Endian的编码。



### 8. CGO 调C函数和GO函数是否在一个goroutine里执行？

不是。如go调c会新建一个线程执行c的程序。



### 9. go的json库解析？

go的json序列化时**无法对小写变量（私有）做序列化**。



### 10. java的编码和go的编码

   分清内码（internal encoding）和外码（external encoding）。

   1、内码 :某种语言运行时，其char和string在内存中的编码方式。

   2、外码 :除了内码，皆是外码。（**源代码编译产生的目标代码文件（可执行文件或class文件）中的编码方式属于外码。**）

   java的**内码的char是utf-16编码（java的char是2字节）**，而外码是采用了utf-8。

   java的外码使用的是改进版utf-8，标准utf-8的表示是1~4个字节，而改进版使用6个字节表示标准utf-8使用4个字节表示的字符，且null采用双字节(char(0))来表示。

   Java的class文件采用UTF8来存储字符，也就是说，class中字符占1～6个字节。

   Java序列化时，字符也采用UTF8编码，占1～6个字节。



### 11. 既然有 HTTP 请求，为什么还要用 RPC 调用？

   使用http请求做rpc调用有以下缺点：

   1. 包含大量http头，**有用信息占比少**
   2. 由于信息体较大，**效率低**
   3. 使用HTTP协议**调用远程方法比较复杂**，要封装各种参数名和参数值。



### 12. 如何判断Java对象是否已经死亡？

这跟具体的GC算法有关，以引用计数法为例，**对象引用计数为0**的时候就是死亡状态，而根据可达性算法分析，则会以所有**GC Roots**作为起点，开始搜索，如果搜索的路径上没有该对象的话，则证明该对象已经死亡。



### 13. 关于基本类型数组的类？

数组类是一种特殊的类，他没有具体的Class文件定义，而是通过虚拟机创建，而相同维度和元素类型的数组类对应同一个 **Class 对象**。

```java
int[] ints = {1, 2};
int[] ints1 = {1, 2, 3};
int[] ints2 = {1, 1, 1};
System.out.println(ints.getClass()==ints1.getClass()); // true
System.out.println(ints1.getClass()==ints2.getClass()); //true
```



### 14. jdk源码用到了哪些设计模式?

例如：

- Java.io 装饰器模式
- java.lang.reflect.Proxy 代理模式
- java.lang.StringBuilder 建造者模式
- java.util.concurrent.ThreadPoolExecutor 策略模式



### 15. serialVersionUID作用？

假如不显式定义，jvm会根据类信息自动计算，那如果类文件做过修改，就会因为不兼容而无法反序列化（**但其实需要序列化的字段可能都没有改变，我们的期望是可以反序列化**），同样由于各机器jvm版本不一致可能也会导致自动生成的serialVersionUID不一样而无法反序列化。



### 16. 浅拷贝和深拷贝区别

- 浅拷贝 浅拷贝是按位拷贝对象，**它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝**。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。
- 深拷贝 **深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存**。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。**如果只是用Object中默认的clone方法，是浅拷贝的**。



### 17. 等待状态和阻塞状态的区别

等待状态指线程正在等待其他线程发来的通知，收到通知后，根据锁竞争情况可能进入运行状态，也可能进入阻塞状态，导致等待状态的方法有：

- Object.wait()
- Object.join()
- LockSupport.park()

阻塞状态指线程阻塞在进入synchronized方法或代码块时的状态。



### 18. 为什么 TCP 协议有粘包问题

TCP 协议是基于字节流的传输层协议，其中不存在消息和数据包的概念，所以其粘包问题是因**为应用层协议开发者的错误设计导致的，**

**应用层协议没有针对TCP使用基于长度或者基于终结符的消息边界**，导致了粘包问题的产生。

解决方法：

1. 使用固定长度，所有的应用层消息都使用统一的大小，多了拆包，少了进行填充；
2. 使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段（如Content-Length），或使用终结符。

[参考文章](https://draveness.me/whys-the-design-tcp-message-frame/)



### 19. 为什么 TCP/IP 协议会拆分数据

IP 协议拆分数据是因为物理设备的限制，一次能够传输的数据由路径上 MTU(Maximum transmission unit) 最小的设备决定，如果发送的数据量超过这个限制会导致丢包；

TCP 协议拆分数据是由于受到底层协议MTU的限制，且为了保证传输的可靠性和顺序而使用拆分得。作为可靠的传输协议，**为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头**，如果TCP不进行拆分，一个过大的TCP数据段被IP协议拆分成两份，只有第一份会有TCP头信息，则如果其中一份丢包，由于缺少有效信息，要重传整个TCP数据段。

[参考文章](https://draveness.me/whys-the-design-tcp-segment-ip-packet/)



### 20. Docker是单进程，但在docker中可以运行多个进程，如何理解？

Docker 单进程指的是只有一个进程是可控的，其余进程类似孤儿进程。



### 21. Dubbo 和 Thrift、Grpc 这些 RPC 协议的区别是什么？

RPC 通信的设计方向主要是两种：

- 服务治理
- 跨语言

Dubbo 属于前者，在提供远程调用的功能基础上集成了注册中心，提供了服务发现以及监控等功能，有较为完善的服务治理逻辑（早起仅支持 Java，现在也有 DubboGo 了。

Thrift 和 Grpc 属于后者，通过一个中间层语言实现了跨语言通信，Thrift 使用 *.thrift 生成各种语言的代码，而 Grpc 使用的是 protobuf（一个效率非常高的序列化协议框架）。



### 22. RMI 和 RPC 的区别？



### 23. HTTP 1.0 1.1 2.0 的区别

http 1.0 -> http 1.1：新增了 长连接 和 pipeline 处理机制。

http 1.1 -> http 2.0：

- header 压缩
- 多路复用
- 采用二进制编码：对 header 和 body 分割成更小的帧，并采用二进制格式编码，增强了性能和健壮性（文本在不同场景下有很多形式）。

[HTTP/1.x 的连接管理](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x)



### 24. classpath 和 classpath* 的区别

classpath：只会到你指定的 class 路径中查找找文件; 
classpath\*：不仅包含 class 路径，还包括 jar 文件中（ class 路径）进行查找.
