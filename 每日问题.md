[toc]

### 1. C&C++的宏定义的作用、应用场景，为什么有大量的宏定义？



### 2. 什么是可重入锁？Java的锁超时怎么使用？

可重入锁指获得该锁的线程在内部可以再次获得该锁而不会报错。



### 3. 反射和new关键字创建对象有什么区别？为什么使用反射？

反射创建实际上把new分解成了两步：

1. 调用class的加载方法加载某个类（`Class.forName()`)；
2. 通过 newInstance() 创建。

区别：

| newInstance      | new                        |
| ---------------- | -------------------------- |
| 弱类型（Object） | 强类型                     |
| 低效率           | 相对高效                   |
| 只能调用无参构造 | 可以调用任意public构造方法 |

如果没有反射机制，每次增加类时，**都需要把类的class文件放在类路径中，再修改源代码new这个类**产生对应类的对象；

有了反射机制后，**只需要在配置文件写上相应的类名称，再通过io流读取配置文件中的类名，即可通过class.forName()方法找出相应的class文件并加载进内存中，再通过newInstance()方法创建一个对象**，此时的对象是一个Object类型的对象，需要转换成相对应的类类型。这样就可以在不修改源代码的情况下通过修改配置文件进行功能的更新和扩展了。



### 4. HashMap 迭代器修改值的问题？



### 5. Maven **代理和私服的区别**？

私服指搭建在局域网内部的仓库，本身是一个仓库，也可以提供许多内部组织的插件和依赖。

代理是用于拦截远程仓库请求，从自己这边找出构件返回给用户。

很多私服搭建工具往往也提供mirror服务。



### 6. 原生态类型有没有泛型参数

没有，通过反射泛型获取不到。



### 7. 什么是大小端？

大端：高位字节在低位地址，地址由小向大增加，而数据从高位往低位放，和字符串显示顺序一致

小端：高位字节在高位地址

一般操作系统都是小端，而通讯协议是大端的。

Java和所有的网络通讯协议都是使用Big-Endian的编码。



### 8. CGO 调C函数和GO函数是否在一个goroutine里执行？

不是。如go调c会新建一个线程执行c的程序。



### 9. go的json库解析？

go的json序列化时**无法对小写变量（私有）做序列化**。



### 10. java的编码和go的编码

   分清内码（internal encoding）和外码（external encoding）。

   1、内码 :某种语言运行时，其char和string在内存中的编码方式。

   2、外码 :除了内码，皆是外码。（**源代码编译产生的目标代码文件（可执行文件或class文件）中的编码方式属于外码。**）

   java的**内码的char是utf-16编码（java的char是2字节）**，而外码是采用了utf-8。

   java的外码使用的是改进版utf-8，标准utf-8的表示是1~4个字节，而改进版使用6个字节表示标准utf-8使用4个字节表示的字符，且null采用双字节(char(0))来表示。

   Java的class文件采用UTF8来存储字符，也就是说，class中字符占1～6个字节。

   Java序列化时，字符也采用UTF8编码，占1～6个字节。



### 11. 既然有 HTTP 请求，为什么还要用 RPC 调用？

   使用http请求做rpc调用有以下缺点：

   1. 包含大量http头，**有用信息占比少**
   2. 由于信息体较大，**效率低**
   3. 使用HTTP协议**调用远程方法比较复杂**，要封装各种参数名和参数值。



### 12. 如何判断Java对象是否已经死亡？

这跟具体的GC算法有关，以引用计数法为例，**对象引用计数为0**的时候就是死亡状态，而根据可达性算法分析，则会以所有**GC Roots**作为起点，开始搜索，如果搜索的路径上没有该对象的话，则证明该对象已经死亡。



### 13. 关于基本类型数组的类？

数组类是一种特殊的类，他没有具体的Class文件定义，而是通过虚拟机创建，而相同维度和元素类型的数组类对应同一个 **Class 对象**。

```java
int[] ints = {1, 2};
int[] ints1 = {1, 2, 3};
int[] ints2 = {1, 1, 1};
System.out.println(ints.getClass()==ints1.getClass()); // true
System.out.println(ints1.getClass()==ints2.getClass()); //true
```



### 14. jdk源码用到了哪些设计模式?

例如：

- Java.io 装饰器模式
- java.lang.reflect.Proxy 代理模式
- java.lang.StringBuilder 建造者模式
- java.util.concurrent.ThreadPoolExecutor 策略模式



### 15. serialVersionUID作用？

假如不显式定义，jvm会根据类信息自动计算，那如果类文件做过修改，就会因为不兼容而无法反序列化（**但其实需要序列化的字段可能都没有改变，我们的期望是可以反序列化**），同样由于各机器jvm版本不一致可能也会导致自动生成的serialVersionUID不一样而无法反序列化。



### 16. 浅拷贝和深拷贝区别

- 浅拷贝 浅拷贝是按位拷贝对象，**它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝**。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。
- 深拷贝 **深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存**。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。**如果只是用Object中默认的clone方法，是浅拷贝的**。



### 17. 等待状态和阻塞状态的区别

等待状态指线程正在等待其他线程发来的通知，收到通知后，根据锁竞争情况可能进入运行状态，也可能进入阻塞状态，导致等待状态的方法有：

- Object.wait()
- Object.join()
- LockSupport.park()

阻塞状态指线程阻塞在进入synchronized方法或代码块时的状态。



### 18. 为什么 TCP 协议有粘包问题

TCP 协议是基于字节流的传输层协议，其中不存在消息和数据包的概念，所以其粘包问题是因**为应用层协议开发者的错误设计导致的，**

**应用层协议没有针对TCP使用基于长度或者基于终结符的消息边界**，导致了粘包问题的产生。

解决方法：

1. 使用固定长度，所有的应用层消息都使用统一的大小，多了拆包，少了进行填充；
2. 使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段（如Content-Length），或使用终结符。

[参考文章](https://draveness.me/whys-the-design-tcp-message-frame/)



### 19. 为什么 TCP/IP 协议会拆分数据

IP 协议拆分数据是因为物理设备的限制，一次能够传输的数据由路径上 MTU(Maximum transmission unit) 最小的设备决定，如果发送的数据量超过这个限制会导致丢包；

TCP 协议拆分数据是由于受到底层协议MTU的限制，且为了保证传输的可靠性和顺序而使用拆分得。作为可靠的传输协议，**为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头**，如果TCP不进行拆分，一个过大的TCP数据段被IP协议拆分成两份，只有第一份会有TCP头信息，则如果其中一份丢包，由于缺少有效信息，要重传整个TCP数据段。

[参考文章](https://draveness.me/whys-the-design-tcp-segment-ip-packet/)



### 20. Docker是单进程，但在docker中可以运行多个进程，如何理解？

Docker 单进程指的是只有一个进程是可控的，其余进程类似孤儿进程。



### 21. Dubbo 和 Thrift、Grpc 这些 RPC 协议的区别是什么？

RPC 通信的设计方向主要是两种：

- 服务治理
- 跨语言

Dubbo 属于前者，在提供远程调用的功能基础上集成了注册中心，提供了服务发现以及监控等功能，有较为完善的服务治理逻辑（早起仅支持 Java，现在也有 DubboGo 了。

Thrift 和 Grpc 属于后者，通过一个中间层语言实现了跨语言通信，Thrift 使用 *.thrift 生成各种语言的代码，而 Grpc 使用的是 protobuf（一个效率非常高的序列化协议框架）。



### 22. RMI 和 RPC 的区别？



### 23. HTTP 1.0 1.1 2.0 的区别？

http 1.0 -> http 1.1：新增了 长连接 和 pipeline 处理机制。

http 1.1 -> http 2.0：

- header 压缩
- 多路复用
- 采用二进制编码：对 header 和 body 分割成更小的帧，并采用二进制格式编码，增强了性能和健壮性（文本在不同场景下有很多形式）。

[HTTP/1.x 的连接管理](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x)



### 24. classpath 和 classpath* 的区别？

classpath：只会到你指定的 class 路径中查找找文件; 
classpath\*：不仅包含 class 路径，还包括 jar 文件中（ class 路径）进行查找.



### 25. delete、drop、truncate 的区别？

delete 属于 DML，只删除数据不删除结构，会走事务，且在 InnoDB 引擎中，DELETE 不会真的删除数据，而是给数据打了个删除标记，这部分磁盘空间不会被直接释放（MyISAM 会直接释放），但下次插入数据时可被直接重用，如果想要立即释放空间需要在 delete 后手动执行 `optimize table xxx`。更重要的是，delete 是一行一行执行的删除操作，因此还会记录 redo 和 undo log，这会占用额外的磁盘空间。**此外 delete 不会重置 auto_increment 的值，但 InnoDB 引擎重启后会被重置为 1**。

drop 属于 DDL，不走事务，**执行后立刻生效，磁盘空间会被立即释放且无法恢复**。 使用 drop 语句会删除表的结构（schema）、约束（constrain）、触发器（trigger）、索引（index），依赖该表的一些存储过程/函数会保留，但是状态为 invalid。

truncate 属于 DDL，不走事务，**执行后立刻生效，磁盘空间会被立即释放且无法恢复**。truncate 的过程有点像 drop table & create table，但由于 table 结构没变，因此 create table 过程做了优化，理论上速度接近于 drop table。truncate 会将 auto_increment 的值重置为 1.



### 26. ClassNotFoundException 和 NoClassDefFound 的区别？

https://cloud.tencent.com/developer/article/1356060



### 27. go 打印 %v %+v %#v 的区别？

-   %v：只输出所有的值；
-   %+v：先输出字段名，再输出字段值；
-   %#v：先输出结构体名，再输出结构体内容（%+v）。



### 28. 蓝绿发布、滚动发布、灰度发布区别？

#### 蓝绿发布

在蓝绿部署中，一共有两套系统：

-   绿色系统：正在提供服务的旧版系统；
-   蓝色系统：准备发布的新系统。

蓝色系统用来做发布前测试，出现问题可以直接在蓝色系统上修改，不影响线上绿色业务。当确定蓝色系统达到标准后，直接将流量切换到蓝色系统，并在切换后的一段时间内，蓝绿并存（绿色系统用于回滚）。当蓝色系统稳定工作一段时间后，绿色系统就可以销毁用于部署下一套蓝色系统，而原先的蓝色系统就成为了绿色系统。

优点：发布时中断时间短，方便回滚；

缺点：需要两倍的集群资源。

#### 滚动发布

滚动发布的特点是将原先的服务区集群划分为多个部分（如目前有 100 台机器，分为 10 组，编号从 1-10），我们只需要额外提供 10 台服务器，更新的时候将新服务部署到这 10 台服务器上，并替换掉集群中的第一组，然后第一组的机器闲置下来，又可以部署新的服务，去替换第二组，以此类推直到第九组替换了第十组，整个服务升级完毕。

优点：额外提供的服务资源少；

缺点：在开始滚动升级后，流量可能直接发向新上的机器，此时新服务还没经过完善测试，因此可能处于一个非常不稳定的状态。

因此，我们需要在滚动发布上的基础上增加流量控制的功能（确保流量发到哪台机器上）。

#### 灰度发布

又称金丝雀发布，在发布新服务时，不断地将小部分流量分发到新服务所在的机器实例上，并观察新服务是否运行正常，若正常，逐步升级其他机器实例的服务或加大新服务所在机器实例的流量，直到所有流量都切换到新服务上。



### 29. Spring注解中，@Bean和@Component有什么区别？

两者的目的都是将 bean 注册到 Spring 容器中，但两者主要有两点区别：

1.  使用 @Component 注解时，Spring 容器扫描到自动生成新的 bean；

    而使用 @Bean 注解时，需要在该注解修饰的方法中自己定义生成 bean 的逻辑。

2.  当使用第三方组件时，一般使用 @Bean 修饰方法将该组件注册到 Spring 容器中，但使用 @Component 则需要在第三方组件源码上增加该注解并配置其类所在路径，不具有实践意义。
